#!/usr/bin/python

import glob
import traceback
import sys
import StringIO
import Underscore

UNDERSCORE = './bin/underscore'
FAILURES  = {}

class TestRun(object):
    def __init__(self, test, env=None):
        self.test = test
        self.env = env if env else {}

    def __enter__(self):
        self._codeOut = StringIO.StringIO()
        sys.stdout = self._codeOut
        return self

    def __exit__(self, _type, _value, _traceback):
        sys.stdout = sys.__stdout__
        self._codeOut.close()
        if _type:
            sys.stdout.write('F')
            FAILURES[self.test] = _type, _value, _traceback
        else:
            sys.stdout.write('.')
        return True

    def execute(self, code):
        exec code in self.env
        output = self._codeOut.getvalue()
        self._codeOut.truncate(0)
        return output

def runTests():
    for test in glob.glob('tests/*py'):
        with TestRun(test) as test_run:
            with open(test) as testfile:
                test_code = testfile.read()
            
            underscore_translation = Underscore.Underscore(test_code)

            expected_output = test_run.execute(test_code)
            actual_output = test_run.execute(underscore_translation)

            if actual_output != expected_output:
                raise AssertionError("Output Error\n" +
                                     "Expected:\n" + expected_output + 
                                     "Actual:\n" + actual_output)

def displayResults():
    print
    for test, exc_info in FAILURES.items():
        print "=" * 100
        print test
        print "=" * 100
        traceback.print_exception(*exc_info)

if __name__ == '__main__':
    print '=' * 100
    runTests()
    displayResults()
